// Utility to regenerate component-registry.ts from database
// Called by /api/dev/publish after saving a component

import fs from 'fs';
import path from 'path';
import { prisma } from './prisma';
import { ComponentStatus } from '@prisma/client';
import { COMPLEX_DEP_PACKAGES } from './component-registry';

/**
 * Convert slug to PascalCase for display name
 * e.g., "liquid-ether" -> "LiquidEther"
 */
function toPascalCase(slug: string): string {
  return slug
    .split('-')
    .map(word => word.charAt(0).toUpperCase() + word.slice(1))
    .join('');
}

/**
 * Regenerate the component-registry.ts file from database
 * Only includes PUBLISHED components with a componentPath
 */
export async function regenerateRegistry(): Promise<number> {
  const components = await prisma.component.findMany({
    where: {
      status: ComponentStatus.PUBLISHED,
      componentPath: { not: null },
    },
    select: {
      slug: true,
      name: true,
      componentPath: true,
      hasComplexDeps: true,
    },
    orderBy: {
      slug: 'asc',
    },
  });

  const entries = components
    .map(c => {
      const displayName = toPascalCase(c.slug);
      return `  '${c.slug}': { path: '${c.componentPath}', hasComplexDeps: ${c.hasComplexDeps}, displayName: '${displayName}' }`;
    })
    .join(',\n');

  const content = `// AUTO-GENERATED - Do not edit manually
// Generated by /api/dev/publish
// This file maps component slugs to their file paths for dynamic imports

export interface RegistryEntry {
  path: string;
  hasComplexDeps: boolean;
  displayName: string;
}

export const COMPONENT_REGISTRY: Record<string, RegistryEntry> = {
${entries}
};

// Complex dependency packages that require file-based imports
// Components with these dependencies cannot be dynamically rendered from DB code
export const COMPLEX_DEP_PACKAGES = [
  'three',
  'gsap',
  '@react-three/fiber',
  '@react-three/drei',
  'lottie-react',
  'matter-js',
  'pixi.js',
  'babylon',
  'd3',
  'canvas',
  'ogl',
];
`;

  const registryPath = path.join(process.cwd(), 'lib', 'component-registry.ts');
  fs.writeFileSync(registryPath, content, 'utf-8');

  console.log(`[Registry] Regenerated with ${components.length} components`);
  return components.length;
}

/**
 * Check if a component has complex dependencies
 * Used by publish API to automatically set hasComplexDeps flag
 */
export function detectComplexDependencies(dependencies: string[]): boolean {
  if (!dependencies || dependencies.length === 0) return false;

  return dependencies.some(dep =>
    COMPLEX_DEP_PACKAGES.some(complexDep =>
      dep.toLowerCase().includes(complexDep.toLowerCase())
    )
  );
}

/**
 * Generate component path from slug
 * Assumes components are stored in @/components/ui/
 */
export function generateComponentPath(slug: string): string {
  const pascalName = toPascalCase(slug);
  return `@/components/ui/${pascalName}`;
}
